<!doctype html>
<html>
  <head>
    <meta charset="utf-8">

    <!-- Always force latest IE rendering engine or request Chrome Frame -->
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">

    <!-- Use title if it's in the page YAML frontmatter -->
    <title>Fullstack Fest 2016. Day 2</title>

    <link href="/stylesheets/normalize.css" rel="stylesheet" type="text/css" /><link href="/stylesheets/all.css" rel="stylesheet" type="text/css" /><link href="/stylesheets/code.css" rel="stylesheet" type="text/css" />
    <script src="/javascripts/all.js" type="text/javascript"></script>
  </head>

  <body class="fullstackfest2016 fullstackfest2016_day2">
    <article>
      <h1>Fullstack Fest 2016</h1>

<p><em>September 6, 2016, Barcelona, Spain</em></p>

<ol>
<li><a href="#how-to-write-a-search-engine-in-15-lines-of-code">How to write a search engine in 15 lines of code</a></li>
<li><a href="#whirlwind-tour-through-the-http2-spec">Whirlwind tour through the HTTP2 spec</a></li>
<li><a href="#microservice-pipeline-architecture">Microservice Pipeline Architecture</a></li>
<li><a href="#the-state-of-serverless">The State Of Serverless</a></li>
<li><a href="#low-res-nlp-for-your-everyday-life">Low-res NLP for your everyday life</a></li>
<li><a href="#distributed-apps-with-ipfs">Distributed Apps with IPFS</a></li>
<li><a href="#from-rest-to-graphql">From REST to GraphQL</a></li>
<li><a href="#building-a-recommendation-engine-with-machine-learning-techniques">Building a Recommendation Engine with Machine Learning Techniques</a>
BY BRIAN SAM-BODDEN</li>
</ol>

<p><a name="how-to-write-a-search-engine-in-15-lines-of-code"></a></p>

<h2>How to write a search engine in 15 lines of code</h2>

<p><em><a href="#">Paul Chiusano</a></em></p>

<p><a href="http://unisonweb.org/">Unison</a> programming language.</p>

<ul>
<li>First-class functions</li>
<li>Types</li>
<li>Persistent key-value storage</li>
</ul>

<p><a name="whirlwind-tour-through-the-http2-spec"></a></p>

<h2>Whirlwind tour through the HTTP2 spec</h2>

<p><em><a href="https://twitter.com/CodeStars">Ole Michaelis</a></em></p>

<h3>FAQ</h3>

<ul>
<li>Is it done? Yes.</li>
<li>Is SSL mandatory? No.</li>
<li>Is it made by Google? No.</li>
<li>Is it plain-text? No.</li>
<li>Are headers compressed? Yes.</li>
<li>Will HTTP/1.1 still work? Yes.</li>
</ul>

<h3>Upgrading from HTTP/1.1</h3>

<p><em>Assuming we already have HTTPS.</em></p>

<ul>
<li>TLS-ALPN (RFC 7301)</li>
<li>h2 (encrypted) vs. h3c (clear-text)</li>
</ul>

<h3>Basics</h3>

<ul>
<li>Frames

<ul>
<li>Connection contains multiple streams</li>
<li>Data withing a stream is transferred in frames</li>
</ul></li>
<li>Server Pushes

<ul>
<li>Server returns a promise</li>
</ul></li>
<li>Header Compression

<ul>
<li>Exchange is in binary format, hence saving bandwidth</li>
</ul></li>
</ul>

<h3>Support</h3>

<ul>
<li>Browser

<ul>
<li>Almost all browsers have HTTP/2 support in their latest versions (except Opera Mini).</li>
</ul></li>
<li><p>Servers</p>

<ul>
<li>Apache via <code>mod_http2</code></li>
</ul>
<pre class="highlight plaintext"><code>LoadModule http2_module mod_http2.so
</code></pre>

<ul>
<li>nginx via <code>http2</code> option in <code>listen</code> directive</li>
</ul>
<pre class="highlight plaintext"><code>listen 443 http2 ssl default_server;
</code></pre>

<ul>
<li>IIS</li>
<li>Amazon ELB</li>
</ul></li>
</ul>

<h3>Future</h3>

<ul>
<li>Cache digests</li>
<li>QUIC (a.k.a. TCP/2 which is actually UDP)</li>
</ul>

<p><a name="microservice-pipeline-architecture"></a></p>

<h2>Microservice Pipeline Architecture</h2>

<p><em><a href="https://twitter.com/pimterry">Tim Perry</a></em></p>

<p><a href="https://speakerdeck.com/pimterry/microservice-pipeline-architecture">Slides</a></p>

<h3>Sync vs. async:</h3>

<p>Sync:
<code>
Content delivery service -&gt; ... -&gt; content services
</code></p>

<p>Async:
<code>
Render + serve -&gt; DB &lt;- load data &lt;- content services
</code></p>

<p>Renderers are data loaders, they may be parallelized.</p>

<p><code>Render + serve</code> part may be broken down to a composer + broker. Web requires responses from broker being
combined into a single (or few) responses.</p>

<p>Ruby implementation: <a href="https://github.com/bbc-news/alephant">Alephant</a>.</p>

<p><a name="the-state-of-serverless"></a></p>

<h2>The State Of Serverless</h2>

<p><em><a href="https://twitter.com/austencollins">Austen Collins</a></em></p>

<p>AWS Lambda:
- microservices
- event-driven
- zero-administraction
- easy access to AWS services
- pay-per-execution</p>

<p><a name="low-res-nlp-for-your-everyday-life"></a></p>

<h2>Low-res NLP for your everyday life</h2>

<p><em><a href="https://twitter.com/duretti">Duretti Hirpa</a></em></p>

<p>Humans are exceptionally good at contexts. Computers are not, but they can learn recognizing contexts
if provided with enough data.</p>

<ul>
<li>Tokenizing words is hard, especially for such languages as Chinese or Korean.</li>
<li>Filter out stop words (do, have, and, etc.)</li>
<li>DB lookup using the meaningful words combination</li>
</ul>

<p><strong>Packages</strong></p>

<ul>
<li><a href="http://superscriptjs.com/">superscriptjs</a>/<a href="https://www.npmjs.com/package/node-normalizer">normalizer</a> - NodeJS package for text normalizetion</li>
<li><a href="http://stanfordnlp.github.io/CoreNLP/">Stanford CoreNLP</a> - tokenizer</li>
<li><a href="https://howdy.ai/">howdy.ai</a> - a library to do NLP in Slack</li>
</ul>

<p><a name="distributed-apps-with-ipfs"></a></p>

<h2>Distributed Apps with IPFS</h2>

<p><em><a href="https://twitter.com/juanbenet">Juan Benet</a></em></p>

<p><a href="https://ipfs.io/">IPFS</a> - InterPlanetary File System, a peer-to-peer hypermedia protocol.</p>

<ul>
<li>Data is distributed across nodes</li>
<li>Data is addressable by its hash</li>
</ul>

<p><a href="https://github.com/ipfs/ipfs">IPFS on GitHub</a>.</p>

<p>Also I am a cyber wizard in 2016.</p>

<p><a name="from-rest-to-graphql"></a></p>

<h2>From REST to GraphQL</h2>

<p><em>[Marc-Andre Giroux](https://twitter.com/</em><em>xuorig</em><em>)</em></p>

<ul>
<li>REST

<ul>
<li>Many round-trips to render a page</li>
</ul></li>
<li>Custom endpoints

<ul>
<li>Tends to turn into a mess when adding parameters to a route</li>
</ul></li>
</ul>

<h3>GraphQL</h3>

<ul>
<li>Lexed</li>
<li>Parsed</li>
<li>Validated</li>
<li>Executed</li>
</ul>

<p>An example query
<code>
{
    myShop {
        name
    }
}
</code></p>

<ul>
<li>GraphQL is typed and can be described as a contract.</li>
<li><code>_schema</code> in a query body to describe types.</li>
<li>Query <code>mutations</code></li>
</ul>

<h3>Drawbacks</h3>

<ul>
<li>N+1 queries
Batching + caching

<ul>
<li>Loader throttles the requests to the API and fires them all in one batch.</li>
<li>HTTP caching doesn&rsquo;t work because of POST requests. Client-side caching to the rescue.</li>
<li>https://github.com/facebook/relay</li>
<li>http://appolostack.com</li>
</ul></li>
<li>Security

<ul>
<li>Timeouts</li>
<li>Query Depth</li>
<li>Query Complexity (weigh the field extraction complexity)</li>
</ul></li>
</ul>

<h3>Future</h3>

<ul>
<li>Technology-agnostic <code>subscriptions</code> (web-sockets, server push, etc.)</li>
<li>Deferred queries - split up the query and send as soon as the part is complete</li>
</ul>

<p><a name="building-a-recommendation-engine-with-machine-learning-techniques"></a></p>

<h2>Building a Recommendation Engine with Machine Learning Techniques</h2>

<p><em><a href="https://twitter.com/bsbodden">Brian Sam-Bodden</a></em></p>

<p><strong>Recommendation engine</strong> predicts the level of user interest that a user might have on a product or item.</p>

<ul>
<li>Why?

<ul>
<li>To combat the paradox of choice</li>
<li>Deal with exmplosion of information coupled with growing user expectations</li>
</ul></li>
</ul>

<p>An <strong>item</strong> is anything that can be represented.</p>

<h3>Approaches</h3>

<ul>
<li>Collaborative filtering (actions of many)</li>
<li>Content-based (characteristics)</li>
<li>Hybrid</li>
</ul>

<h3>Learning ML</h3>

<ul>
<li>Supervised

<ul>
<li>Classification</li>
<li>Regression</li>
</ul></li>
<li><p>Unsupervised</p>

<ul>
<li>Grouping</li>
<li>Anomaly Detection</li>
</ul></li>
<li><p>Get the big picture first</p></li>
<li><p>Play with small code samples</p></li>
<li><p>Focus on the [meaningful] data first (and algorithms too!)</p></li>
</ul>

<p><a href="https://rapidminer.com/">Rapidminer</a> - predictive analytics platform.</p>

<h3>Collaborative filtering</h3>

<ul>
<li>Collecting feedback

<ul>
<li>Explicitly - likes, rating, etc.</li>
<li>Implicitly - purchase, search, browse</li>
</ul></li>
</ul>

<h4>User-based collabortive filtering</h4>

<ul>
<li>Relies on finding similar users</li>
<li>Similarity based on items in common</li>
<li>Use similar user ratings to predict rating</li>
</ul>

<p><strong>k-NN algorithm</strong> - prediction is the average of the neighbors.</p>

<h5>Drawbacks</h5>

<ul>
<li>Performs poorly if not enough ratings</li>
<li>Expensive to compute similarity between all users</li>
<li>Needs to be recalculated if users&#39; tastes change</li>
</ul>

<h4>Item-based filtering</h4>

<ul>
<li>Recommendations as a ML problem</li>
<li>Classify items according to their content</li>
<li>Recommend items that match users&#39; interests</li>
</ul>

<h5>Advantages</h5>

<ul>
<li>Items do not tend to change</li>
<li>Smaller data set</li>
<li>Faster to compute, cheaper to store</li>
</ul>

<h3>Using world knowledge</h3>

<p>Use Wikipedia as a knowledge repository! Lots of items are already factorized (categories, tags, etc.).</p>

    </article>
  </body>
</html>
